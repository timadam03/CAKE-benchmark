{
  "batch": "design",
  "count": 19,
  "questions": [
    {
      "id": "Q113",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a disaster recovery strategy for a critical financial application. Requirements: RTO of 4 hours, RPO of 15 minutes, budget constraints prevent active-active in multiple regions. Which approach best fits?",
      "options": [
        "Warm standby in secondary region with continuous replication and automated failover",
        "Daily backups to another region",
        "Active-active multi-region deployment",
        "Cold standby with weekly backups"
      ],
      "correct_answer": "Warm standby in secondary region with continuous replication and automated failover",
      "explanation": "Warm standby meets the 4-hour RTO (quick spinup) and 15-minute RPO (continuous replication) without the cost of active-active. Cold standby is too slow for 4-hour RTO.",
      "concept_ids": [
        "CONCEPT-033",
        "CONCEPT-034"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q116",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "free_response",
      "question": "Design API versioning strategy for a public API with 500 enterprise customers. Requirements: 6-month deprecation window, clear migration path, support parallel versions, minimize customer disruption. Include versioning approach and deprecation process.",
      "correct_answer": "Versioning approach: URL path versioning (/v1/, /v2/) for clarity and routing simplicity. Process: 1) New version development in parallel with current version. 2) Announce deprecation with 6-month countdown in API responses (Sunset header, deprecation warnings). 3) Provide migration guides and SDK updates. 4) Analytics to track version usage per customer. 5) Direct outreach to customers still on deprecated versions. 6) Grace period extensions for strategic customers. 7) Final deprecation with clear cutoff date. Technical: API Gateway routes by version, shared backend services where compatible, version-specific adapters where needed. Documentation: Changelog, migration guide, version comparison, sunset timeline. Communication: Email announcements, developer portal notices, API response warnings.",
      "explanation": "URL versioning is most explicit for enterprise customers. The deprecation process balances business needs with technical evolution.",
      "concept_ids": [
        "CONCEPT-057",
        "CONCEPT-068"
      ],
      "sources": [
        "ADRs",
        "Kubernetes KEPs"
      ]
    },
    {
      "id": "Q117",
      "skill": "design",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a caching strategy for a product catalog service. Requirements: 1M products, 100K reads/minute, updates every 5 minutes from suppliers, 99.9% cache hit rate target. Products have images (10MB each) and metadata (1KB). Which approach?",
      "options": [
        "Redis for metadata cache-aside, CDN for images, async cache invalidation on updates",
        "Cache everything in Redis including images",
        "No caching, scale the database",
        "Browser caching only"
      ],
      "correct_answer": "Redis for metadata cache-aside, CDN for images, async cache invalidation on updates",
      "explanation": "Separate concerns: Redis efficiently caches small metadata, CDN handles large images at edge. Cache-aside with async invalidation handles the 5-minute update cycle appropriately.",
      "concept_ids": [
        "CONCEPT-038"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q121",
      "skill": "design",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a CI/CD pipeline for a microservices team. Requirements: 10 services in a monorepo, independent deployments, automated testing, deployment to Kubernetes. Which approach?",
      "options": [
        "Selective builds based on changed paths, service-specific pipelines, GitOps with ArgoCD for deployment",
        "Single pipeline that builds and deploys everything on every change",
        "Manual deployments after testing",
        "Branch per service with merge to main for deployment"
      ],
      "correct_answer": "Selective builds based on changed paths, service-specific pipelines, GitOps with ArgoCD for deployment",
      "explanation": "Path-based selective builds handle monorepo efficiency. Service-specific pipelines enable independent deployments. ArgoCD provides GitOps-based Kubernetes deployment.",
      "concept_ids": [
        "CONCEPT-052",
        "CONCEPT-053",
        "CONCEPT-036"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q124",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "free_response",
      "question": "Design a data mesh architecture for a large enterprise with multiple business domains: Sales, Marketing, Finance, Operations. Each domain should own their data products. Include governance and interoperability considerations.",
      "correct_answer": "Data Mesh Design: Domain-oriented ownership: Each domain (Sales, Marketing, Finance, Ops) owns data products as first-class citizens. Infrastructure: 1) Self-serve data platform providing compute, storage, and catalog capabilities, 2) Federated computational governance with automated policy enforcement, 3) Standardized interfaces (APIs, event streams) for data product consumption. Data Products per domain: Sales (leads, opportunities, forecasts), Marketing (campaigns, attribution, segments), Finance (revenue, costs, budgets), Ops (inventory, fulfillment, logistics). Interoperability: 1) Standard metadata schemas across domains, 2) Data contracts with SLOs, 3) Cross-domain access via governed APIs, 4) Central catalog for discovery. Governance: Automated quality checks, data lineage tracking, access policies, retention compliance. Implementation: Start with one domain, prove model, expand. Anti-pattern to avoid: central data team owning all data.",
      "explanation": "Data mesh applies domain-driven design to data, with domains owning their data products. Self-serve platform and federated governance enable scaling.",
      "concept_ids": [
        "CONCEPT-017",
        "CONCEPT-018",
        "CONCEPT-065"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q125",
      "skill": "design",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design auto-scaling for an e-commerce platform expecting 10x traffic during flash sales (known events) and 3x spikes during normal operation (unknown events). Which scaling configuration?",
      "options": [
        "Scheduled scaling for known events, target tracking for normal operation, with pre-warming for flash sales",
        "Manual scaling before flash sales",
        "Only reactive auto-scaling based on CPU",
        "Fixed capacity for peak load"
      ],
      "correct_answer": "Scheduled scaling for known events, target tracking for normal operation, with pre-warming for flash sales",
      "explanation": "Scheduled scaling pre-provisions for known 10x events. Target tracking handles unknown 3x spikes reactively. Pre-warming ensures instances are ready for traffic.",
      "concept_ids": [
        "CONCEPT-040"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q131",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a data backup strategy for a globally distributed application with databases in 3 regions. Requirements: cross-region recovery, 1-hour RPO, 4-hour RTO, encryption at rest.",
      "options": [
        "Continuous replication to central backup region, point-in-time recovery enabled, encrypted snapshots, tested restore procedures",
        "Daily backups to same region",
        "Manual exports weekly",
        "No backups, rely on replication"
      ],
      "correct_answer": "Continuous replication to central backup region, point-in-time recovery enabled, encrypted snapshots, tested restore procedures",
      "explanation": "Continuous replication meets 1-hour RPO. Central backup enables cross-region recovery. Point-in-time recovery provides flexibility. Tested procedures ensure 4-hour RTO.",
      "concept_ids": [
        "CONCEPT-033",
        "CONCEPT-034"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q133",
      "skill": "design",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design message handling for an order system where processing must happen exactly once. Messages may be redelivered due to consumer failures. Which approach ensures correctness?",
      "options": [
        "Idempotent consumer with message ID tracking in the same transaction as business logic",
        "Rely on exactly-once delivery from message broker",
        "Process all messages regardless of duplicates",
        "Manual deduplication by operators"
      ],
      "correct_answer": "Idempotent consumer with message ID tracking in the same transaction as business logic",
      "explanation": "Most message systems provide at-least-once delivery. Idempotent consumers with transactional ID tracking ensure exactly-once processing semantics.",
      "concept_ids": [
        "CONCEPT-024"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q135",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design an SLO framework for a microservices platform. You need to define SLOs, measure SLIs, and create error budgets. Which approach is most comprehensive?",
      "options": [
        "Define latency (p99) and availability SLOs per service, measure with distributed tracing, calculate error budget burn rate for release decisions",
        "Track only uptime percentage",
        "Use average latency for all measurements",
        "Measure only customer complaints"
      ],
      "correct_answer": "Define latency (p99) and availability SLOs per service, measure with distributed tracing, calculate error budget burn rate for release decisions",
      "explanation": "P99 latency captures tail experience. Per-service SLOs enable accountability. Error budgets tie reliability to deployment velocity.",
      "concept_ids": [
        "CONCEPT-021",
        "CONCEPT-020"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q137",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design data contracts between services in a microservices architecture. The Order Service needs Customer data from Customer Service. Which approach minimizes coupling while ensuring reliability?",
      "options": [
        "Customer Service publishes events with required data, Order Service maintains local cache updated via events",
        "Order Service directly queries Customer database",
        "Shared Customer library across all services",
        "Synchronous API call on every order"
      ],
      "correct_answer": "Customer Service publishes events with required data, Order Service maintains local cache updated via events",
      "explanation": "Event-driven data sharing minimizes runtime coupling. Local cache provides availability. Events define the contract. This is the Data Mesh/event-carried state transfer pattern.",
      "concept_ids": [
        "CONCEPT-005",
        "CONCEPT-062"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q139",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a chaos engineering program for a company new to the practice. They have 20 microservices in production with basic monitoring. What's the best starting approach?",
      "options": [
        "Start with GameDays in staging, simple failure injection (pod kill), graduate to production with small blast radius",
        "Immediately run chaos experiments in production at scale",
        "Only theoretical analysis without actual injection",
        "Chaos engineering only after all services are fully resilient"
      ],
      "correct_answer": "Start with GameDays in staging, simple failure injection (pod kill), graduate to production with small blast radius",
      "explanation": "Start small and safe: staging first, simple failures, build confidence and improve observability before production. Gradually increase scope and complexity.",
      "concept_ids": [
        "CONCEPT-037"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q141",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design service communication for an order processing system. Order Service needs to call Payment Service (critical, needs response) and Notification Service (non-critical, can fail). Which communication patterns?",
      "options": [
        "Synchronous call with Circuit Breaker for Payment, async message queue for Notification",
        "Synchronous calls for both with long timeouts",
        "Async message queue for both",
        "Direct database sharing"
      ],
      "correct_answer": "Synchronous call with Circuit Breaker for Payment, async message queue for Notification",
      "explanation": "Critical paths (Payment) need synchronous calls with resilience patterns. Non-critical paths (Notification) benefit from async decoupling - failure doesn't block order.",
      "concept_ids": [
        "CONCEPT-001",
        "CONCEPT-023"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q143",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a structured error handling strategy for a public API. Errors need to be: actionable for clients, secure (no internal details exposed), consistent across services, and debuggable for operators.",
      "options": [
        "RFC 7807 Problem Details format with error codes, correlation IDs in response and logs, separate internal vs external error messages",
        "Stack traces in API responses",
        "Generic 500 Internal Server Error for all failures",
        "Error codes without descriptions"
      ],
      "correct_answer": "RFC 7807 Problem Details format with error codes, correlation IDs in response and logs, separate internal vs external error messages",
      "explanation": "RFC 7807 provides standard format. Error codes enable client handling. Correlation IDs link client errors to server logs. Separation protects internals.",
      "concept_ids": [
        "CONCEPT-066"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q145",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a testing strategy for microservices. You have 15 services with complex dependencies. Full integration tests take 2 hours. How do you balance test coverage with developer productivity?",
      "options": [
        "Unit tests per service, contract tests for service boundaries, selective integration tests based on changes, full integration in nightly builds",
        "Only unit tests for speed",
        "Only full integration tests for coverage",
        "Manual testing only"
      ],
      "correct_answer": "Unit tests per service, contract tests for service boundaries, selective integration tests based on changes, full integration in nightly builds",
      "explanation": "Testing pyramid: fast unit tests for most coverage, contract tests catch interface breaks, selective integration for changed areas, comprehensive nightly for full validation.",
      "concept_ids": [
        "CONCEPT-083",
        "CONCEPT-052"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q149",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design team structure for a microservices platform with 8 services. Each service should be owned by a team, but you only have 25 engineers. How should teams be organized?",
      "options": [
        "3-4 cross-functional teams, each owning 2-3 related services based on domain boundaries",
        "One team owning all services",
        "8 teams with 3 engineers each",
        "Separate teams for frontend, backend, and DevOps"
      ],
      "correct_answer": "3-4 cross-functional teams, each owning 2-3 related services based on domain boundaries",
      "explanation": "Two-pizza team size (6-8 people) owns related services within a domain. Cross-functional includes all needed skills. Aligns with Conway's Law.",
      "concept_ids": [
        "CONCEPT-043",
        "CONCEPT-016"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q151",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design an incident response process for a 24/7 SaaS platform. Team of 20 engineers across 3 time zones. Need: clear escalation, minimal burnout, effective communication.",
      "options": [
        "Follow-the-sun on-call rotation, severity-based escalation matrix, incident commander role, post-incident reviews, runbooks for common issues",
        "Single person on-call 24/7",
        "No on-call, address issues next business day",
        "Entire team responds to every incident"
      ],
      "correct_answer": "Follow-the-sun on-call rotation, severity-based escalation matrix, incident commander role, post-incident reviews, runbooks for common issues",
      "explanation": "Follow-the-sun leverages time zones to avoid 24-hour on-call. Severity-based escalation prevents over-alerting. Incident commander coordinates response. Runbooks enable efficient resolution.",
      "concept_ids": [
        "CONCEPT-070",
        "CONCEPT-066"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q153",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design an integration strategy for a microservices platform that must connect with 20 different external partners. Each partner has different API formats, auth methods, and reliability characteristics.",
      "options": [
        "Integration Service with adapter per partner, circuit breakers per partner, async messaging for non-real-time, standardized internal events",
        "Direct calls from each microservice to partners",
        "Single universal API wrapper",
        "Manual integration scripts"
      ],
      "correct_answer": "Integration Service with adapter per partner, circuit breakers per partner, async messaging for non-real-time, standardized internal events",
      "explanation": "Adapter pattern handles API differences. Circuit breakers isolate partner failures. Async messaging decouples when possible. Internal events standardize consumption.",
      "concept_ids": [
        "CONCEPT-015",
        "CONCEPT-001"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q157",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "You're designing a platform that will be white-labeled for multiple enterprise customers. Each customer wants customization: branding, feature toggles, custom fields. What's the best multi-tenancy approach?",
      "options": [
        "Shared infrastructure with tenant-aware customization layer, configuration per tenant, feature flags for optional features",
        "Separate deployment per customer",
        "Fork the codebase per customer",
        "No customization allowed"
      ],
      "correct_answer": "Shared infrastructure with tenant-aware customization layer, configuration per tenant, feature flags for optional features",
      "explanation": "Shared infrastructure reduces operational burden. Tenant-aware customization layer handles branding/fields. Feature flags enable per-tenant features. Single codebase is maintainable.",
      "concept_ids": [
        "CONCEPT-056",
        "CONCEPT-081"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q159",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a sustainable architecture for a cloud application. The company has committed to carbon neutrality. Which design choices most directly reduce environmental impact?",
      "options": [
        "Right-size resources for high utilization, schedule non-critical jobs for low-carbon periods, use serverless for variable workloads, prefer managed services",
        "Use the largest instances available",
        "Run 24/7 at peak capacity",
        "Deploy in multiple regions for redundancy only"
      ],
      "correct_answer": "Right-size resources for high utilization, schedule non-critical jobs for low-carbon periods, use serverless for variable workloads, prefer managed services",
      "explanation": "Higher utilization means less idle capacity. Scheduling for low-carbon grid periods reduces emissions. Serverless and managed services share resources efficiently.",
      "concept_ids": [
        "CONCEPT-071"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    }
  ]
}