{
  "metadata": {
    "name": "Core",
    "description": "CAKE (Core) \u2014 Cloud Architecture Knowledge Evaluation benchmark",
    "total_questions": 116,
    "distribution": {
      "by_skill": {
        "analyze": 40,
        "design": 19,
        "implement": 16,
        "recall": 41
      },
      "by_topic": {
        "architectural_patterns": 44,
        "cloud_deployment": 16,
        "decomposition": 27,
        "quality_attributes": 25,
        "technical_debt": 4
      },
      "by_format": {
        "free_response": 22,
        "mcq": 94
      }
    }
  },
  "questions": [
    {
      "id": "Q001",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What are the three states of a Circuit Breaker pattern?",
      "options": [
        "Open, Closed, Half-Open",
        "Active, Inactive, Pending",
        "Running, Stopped, Paused",
        "Connected, Disconnected, Reconnecting"
      ],
      "correct_answer": "Open, Closed, Half-Open",
      "explanation": "The Circuit Breaker pattern uses three states: Closed (normal operation), Open (blocking requests after failures exceed threshold), and Half-Open (testing if service has recovered).",
      "concept_ids": [
        "CONCEPT-001"
      ],
      "sources": [
        "microservices.io",
        "Azure Patterns"
      ]
    },
    {
      "id": "Q002",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What does CQRS stand for?",
      "options": [
        "Command Query Responsibility Segregation",
        "Concurrent Query Response System",
        "Central Query Routing Service",
        "Command Queue Read Separation"
      ],
      "correct_answer": "Command Query Responsibility Segregation",
      "explanation": "CQRS (Command Query Responsibility Segregation) separates read and write models, enabling independent optimization and scaling of each.",
      "concept_ids": [
        "CONCEPT-003"
      ],
      "sources": [
        "Martin Fowler",
        "microservices.io"
      ]
    },
    {
      "id": "Q003",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What does RTO stand for in disaster recovery?",
      "options": [
        "Recovery Time Objective",
        "Real-Time Operations",
        "Rollback Transaction Order",
        "Resource Timeout Option"
      ],
      "correct_answer": "Recovery Time Objective",
      "explanation": "RTO (Recovery Time Objective) is the maximum acceptable downtime after a disaster before business impact becomes unacceptable.",
      "concept_ids": [
        "CONCEPT-034"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q004",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "easy",
      "format": "mcq",
      "question": "Which pattern persists state as a sequence of immutable events rather than current state?",
      "options": [
        "Event Sourcing",
        "CQRS",
        "Saga",
        "Outbox"
      ],
      "correct_answer": "Event Sourcing",
      "explanation": "Event Sourcing persists business entities as a sequence of state-changing events, enabling complete audit trails, temporal queries, and event replay.",
      "concept_ids": [
        "CONCEPT-004"
      ],
      "sources": [
        "Martin Fowler",
        "microservices.io"
      ]
    },
    {
      "id": "Q005",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is Conway's Law about?",
      "options": [
        "Organizations design systems that mirror their communication structure",
        "Systems should be designed for maximum performance",
        "All microservices should be the same size",
        "Databases should be normalized to third normal form"
      ],
      "correct_answer": "Organizations design systems that mirror their communication structure",
      "explanation": "Conway's Law states that organizations design systems that mirror their communication structure, meaning team structure influences system architecture.",
      "concept_ids": [
        "CONCEPT-043"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q007",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What pattern uses a queue as a buffer between producers and consumers to smooth load spikes?",
      "options": [
        "Queue-Based Load Leveling",
        "Circuit Breaker",
        "Bulkhead",
        "Throttling"
      ],
      "correct_answer": "Queue-Based Load Leveling",
      "explanation": "Queue-Based Load Leveling uses a queue to buffer requests, allowing consumers to process at their own pace regardless of producer load.",
      "concept_ids": [
        "CONCEPT-012"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q008",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What does the Strangler Fig pattern help with?",
      "options": [
        "Incrementally migrating legacy systems to new architecture",
        "Improving database performance",
        "Implementing authentication",
        "Scaling horizontally"
      ],
      "correct_answer": "Incrementally migrating legacy systems to new architecture",
      "explanation": "The Strangler Fig pattern enables incremental migration of legacy systems by building new functionality alongside the old system and gradually transferring traffic.",
      "concept_ids": [
        "CONCEPT-008"
      ],
      "sources": [
        "Martin Fowler",
        "Azure Patterns"
      ]
    },
    {
      "id": "Q009",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is Infrastructure as Code (IaC)?",
      "options": [
        "Managing infrastructure through code and automation",
        "Writing application code for cloud",
        "Coding inside virtual machines",
        "Using code editors in the cloud"
      ],
      "correct_answer": "Managing infrastructure through code and automation",
      "explanation": "Infrastructure as Code (IaC) is the practice of defining and managing infrastructure through code, enabling version control, testing, and reproducibility.",
      "concept_ids": [
        "CONCEPT-035"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q010",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What security principle grants only the minimum permissions necessary for a task?",
      "options": [
        "Principle of Least Privilege",
        "Defense in Depth",
        "Zero Trust",
        "Separation of Duties"
      ],
      "correct_answer": "Principle of Least Privilege",
      "explanation": "The Principle of Least Privilege grants only the minimum permissions necessary to perform a task, reducing attack surface and potential damage.",
      "concept_ids": [
        "CONCEPT-030"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q011",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "In the Saga pattern, what are compensating transactions used for?",
      "options": [
        "Undoing the effects of previous transactions when rollback is needed",
        "Speeding up transaction processing",
        "Combining multiple transactions into one",
        "Logging transaction history"
      ],
      "correct_answer": "Undoing the effects of previous transactions when rollback is needed",
      "explanation": "Compensating transactions in a Saga undo the effects of previously completed local transactions when a later step fails and rollback is required.",
      "concept_ids": [
        "CONCEPT-002",
        "CONCEPT-080"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q012",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "In Domain-Driven Design, what are the three types of subdomains?",
      "options": [
        "Core, Supporting, Generic",
        "Primary, Secondary, Tertiary",
        "Main, Helper, Utility",
        "Business, Technical, Infrastructure"
      ],
      "correct_answer": "Core, Supporting, Generic",
      "explanation": "DDD classifies subdomains as Core (key differentiators), Supporting (related but not differentiating), and Generic (business-agnostic, suitable for off-the-shelf solutions).",
      "concept_ids": [
        "CONCEPT-017"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q015",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the Bulkhead pattern named after?",
      "options": [
        "Ship compartments that prevent total flooding",
        "Building support structures",
        "Electronic circuit components",
        "Bridge construction elements"
      ],
      "correct_answer": "Ship compartments that prevent total flooding",
      "explanation": "The Bulkhead pattern is named after ship compartments that prevent total flooding if one section is compromised, similarly isolating failures in software.",
      "concept_ids": [
        "CONCEPT-009"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q016",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is a Service Mesh?",
      "options": [
        "Infrastructure layer handling service-to-service communication with sidecar proxies",
        "A network of microservices",
        "A type of container orchestration",
        "A load balancing algorithm"
      ],
      "correct_answer": "Infrastructure layer handling service-to-service communication with sidecar proxies",
      "explanation": "A Service Mesh is an infrastructure layer that handles service-to-service communication with features like mTLS, traffic management, and observability via sidecar proxies.",
      "concept_ids": [
        "CONCEPT-046"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q017",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the difference between Sidecar and Ambassador patterns?",
      "options": [
        "Sidecar is co-located for general functionality; Ambassador specifically handles outbound connectivity",
        "They are identical patterns with different names",
        "Sidecar is for databases; Ambassador is for APIs",
        "Ambassador is older; Sidecar is the modern version"
      ],
      "correct_answer": "Sidecar is co-located for general functionality; Ambassador specifically handles outbound connectivity",
      "explanation": "Sidecar provides general supporting functionality co-located with the main app, while Ambassador specifically proxies outbound connectivity features like circuit breaking and routing.",
      "concept_ids": [
        "CONCEPT-013",
        "CONCEPT-014"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q019",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is a Bounded Context in Domain-Driven Design?",
      "options": [
        "A boundary where domain terms have specific, consistent meanings",
        "A limit on the size of a microservice",
        "A container for database transactions",
        "A security perimeter around services"
      ],
      "correct_answer": "A boundary where domain terms have specific, consistent meanings",
      "explanation": "A Bounded Context is a DDD pattern that divides large domain models into segments with explicit boundaries where terms have specific, consistent meanings.",
      "concept_ids": [
        "CONCEPT-018"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q021",
      "skill": "recall",
      "topic": "technical_debt",
      "difficulty": "easy",
      "format": "mcq",
      "question": "According to the Technical Debt metaphor, what represents 'interest payments'?",
      "options": [
        "Extra effort required to add new features due to poor code quality",
        "Actual financial costs of development",
        "Time spent in meetings",
        "Server maintenance costs"
      ],
      "correct_answer": "Extra effort required to add new features due to poor code quality",
      "explanation": "In the Technical Debt metaphor, interest payments are the extra effort required to add features or fix bugs due to suboptimal code quality.",
      "concept_ids": [
        "CONCEPT-029"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q022",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the 'Microservice Premium'?",
      "options": [
        "The overhead cost of managing multiple services compared to a monolith",
        "A pricing model for microservice platforms",
        "Premium features in microservice frameworks",
        "Extra performance from microservices"
      ],
      "correct_answer": "The overhead cost of managing multiple services compared to a monolith",
      "explanation": "The Microservice Premium is the additional overhead (complexity, operational cost) of managing multiple services compared to a monolith.",
      "concept_ids": [
        "CONCEPT-060"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q023",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is an Idempotent Consumer?",
      "options": [
        "A consumer that produces the same result when processing the same message multiple times",
        "A consumer that only processes unique messages",
        "A consumer that consumes messages in order",
        "A consumer that never fails"
      ],
      "correct_answer": "A consumer that produces the same result when processing the same message multiple times",
      "explanation": "An Idempotent Consumer can safely process the same message multiple times while producing the same result, handling message redelivery gracefully.",
      "concept_ids": [
        "CONCEPT-024"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q024",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is the main benefit of serverless deployment?",
      "options": [
        "No infrastructure management required",
        "Guaranteed lowest cost",
        "Fastest execution speed",
        "Unlimited execution time"
      ],
      "correct_answer": "No infrastructure management required",
      "explanation": "Serverless deployment eliminates infrastructure management, allowing developers to focus on code while the platform handles scaling and billing per-use.",
      "concept_ids": [
        "CONCEPT-026"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q025",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is a Health Check API used for?",
      "options": [
        "Reporting service's ability to handle requests for routing and self-healing decisions",
        "Checking developer health",
        "Monitoring server hardware",
        "Validating API schemas"
      ],
      "correct_answer": "Reporting service's ability to handle requests for routing and self-healing decisions",
      "explanation": "A Health Check API returns whether a service can handle requests, used by platforms for routing decisions and triggering self-healing actions.",
      "concept_ids": [
        "CONCEPT-022"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q027",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is GitOps?",
      "options": [
        "Using Git as single source of truth for infrastructure with automated synchronization",
        "Using Git for code versioning",
        "Operating systems for Git servers",
        "Git operations in production"
      ],
      "correct_answer": "Using Git as single source of truth for infrastructure with automated synchronization",
      "explanation": "GitOps uses Git as the single source of truth for declarative infrastructure and applications, with automated synchronization to live environments.",
      "concept_ids": [
        "CONCEPT-036"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q028",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "mcq",
      "question": "According to CAP theorem, what three properties cannot all be guaranteed simultaneously?",
      "options": [
        "Consistency, Availability, Partition tolerance",
        "Capacity, Agility, Performance",
        "Cost, Accuracy, Precision",
        "Compliance, Auditing, Privacy"
      ],
      "correct_answer": "Consistency, Availability, Partition tolerance",
      "explanation": "CAP theorem states that a distributed system can only guarantee two of three properties: Consistency, Availability, and Partition tolerance.",
      "concept_ids": [
        "CONCEPT-041"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q029",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is Chaos Engineering?",
      "options": [
        "Deliberately injecting failures to test system resilience",
        "Managing chaotic development processes",
        "Debugging complex systems",
        "Random code refactoring"
      ],
      "correct_answer": "Deliberately injecting failures to test system resilience",
      "explanation": "Chaos Engineering deliberately injects failures into systems to test resilience and discover weaknesses before they cause production incidents.",
      "concept_ids": [
        "CONCEPT-037"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q030",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is the 'Database per Service' pattern?",
      "options": [
        "Each microservice owns and manages its private database",
        "One database shared across all services",
        "Multiple databases per service",
        "No databases in microservices"
      ],
      "correct_answer": "Each microservice owns and manages its private database",
      "explanation": "Database per Service means each microservice owns its private database, accessible only through its API, enabling loose coupling and polyglot persistence.",
      "concept_ids": [
        "CONCEPT-005"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q031",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is Polyglot Persistence?",
      "options": [
        "Using different database technologies for different services based on their needs",
        "Storing data in multiple languages",
        "Using a single database that supports multiple query languages",
        "Persisting code in multiple programming languages"
      ],
      "correct_answer": "Using different database technologies for different services based on their needs",
      "explanation": "Polyglot Persistence uses different database technologies optimized for different services' needs rather than a single shared database for all.",
      "concept_ids": [
        "CONCEPT-045"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q032",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is Blue-Green Deployment?",
      "options": [
        "Maintaining two production environments and switching traffic between them",
        "Using blue and green colored servers",
        "Deploying to staging then production",
        "A type of container deployment"
      ],
      "correct_answer": "Maintaining two production environments and switching traffic between them",
      "explanation": "Blue-Green Deployment maintains two production environments (blue and green), deploys to the inactive one, then switches traffic for instant rollback capability.",
      "concept_ids": [
        "CONCEPT-054"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q033",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is Canary Deployment?",
      "options": [
        "Gradually rolling out changes to a subset of users before full deployment",
        "Deploying to test environments first",
        "Using canary servers for testing",
        "A type of blue-green deployment"
      ],
      "correct_answer": "Gradually rolling out changes to a subset of users before full deployment",
      "explanation": "Canary Deployment gradually rolls out changes to a small subset of users, detecting issues with limited blast radius before full deployment.",
      "concept_ids": [
        "CONCEPT-055"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q034",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is an API Gateway?",
      "options": [
        "A single entry point that routes requests to appropriate backend services",
        "A database for API definitions",
        "A tool for generating API documentation",
        "A testing framework for APIs"
      ],
      "correct_answer": "A single entry point that routes requests to appropriate backend services",
      "explanation": "An API Gateway is a single entry point that routes requests to backend services, providing protocol translation, authentication, and response aggregation.",
      "concept_ids": [
        "CONCEPT-006"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q035",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the Anti-Corruption Layer pattern used for?",
      "options": [
        "Translating between systems with different semantics to prevent legacy models from corrupting new designs",
        "Preventing data corruption in databases",
        "Encrypting data in transit",
        "Validating input data"
      ],
      "correct_answer": "Translating between systems with different semantics to prevent legacy models from corrupting new designs",
      "explanation": "The Anti-Corruption Layer translates between systems with different semantics, preventing legacy or external system models from corrupting new application design.",
      "concept_ids": [
        "CONCEPT-015"
      ],
      "sources": [
        "Azure Patterns",
        "microservices.io"
      ]
    },
    {
      "id": "Q037",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "mcq",
      "question": "What problem does Two-Phase Commit (2PC) solve, and why is it problematic for microservices?",
      "options": [
        "Ensures distributed transaction atomicity but blocks and reduces availability",
        "Improves query performance but increases complexity",
        "Enables service discovery but requires central coordinator",
        "Provides encryption but slows communication"
      ],
      "correct_answer": "Ensures distributed transaction atomicity but blocks and reduces availability",
      "explanation": "2PC ensures all participants in a distributed transaction commit or abort together, but it's blocking and reduces availability, making it problematic for microservices.",
      "concept_ids": [
        "CONCEPT-044"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q038",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is Eventual Consistency?",
      "options": [
        "Guarantee that reads will eventually return the last updated value if no new updates are made",
        "Immediate consistency across all replicas",
        "Consistency that eventually fails",
        "A weaker form of ACID consistency"
      ],
      "correct_answer": "Guarantee that reads will eventually return the last updated value if no new updates are made",
      "explanation": "Eventual Consistency guarantees that if no new updates are made, eventually all reads will return the last updated value, trading immediate consistency for availability.",
      "concept_ids": [
        "CONCEPT-042"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q039",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is Service Discovery?",
      "options": [
        "Mechanism for services to find network locations of other services",
        "Finding new microservices to implement",
        "Discovering service documentation",
        "A testing technique"
      ],
      "correct_answer": "Mechanism for services to find network locations of other services",
      "explanation": "Service Discovery is a mechanism for services to find network locations of other services, using client-side, server-side, or DNS-based approaches.",
      "concept_ids": [
        "CONCEPT-077"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q040",
      "skill": "recall",
      "topic": "technical_debt",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What does Semantic Versioning's MAJOR version number indicate?",
      "options": [
        "Breaking changes that may require modifications to dependent code",
        "New features with backward compatibility",
        "Bug fixes only",
        "Documentation updates"
      ],
      "correct_answer": "Breaking changes that may require modifications to dependent code",
      "explanation": "In Semantic Versioning (MAJOR.MINOR.PATCH), incrementing MAJOR indicates breaking changes that may require modifications to dependent code.",
      "concept_ids": [
        "CONCEPT-082"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q041",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the 'Shared Database' anti-pattern?",
      "options": [
        "Multiple services sharing a single database, creating tight coupling",
        "Using a database that supports sharing",
        "Sharing database credentials",
        "Having backup databases"
      ],
      "correct_answer": "Multiple services sharing a single database, creating tight coupling",
      "explanation": "The Shared Database anti-pattern occurs when multiple services share a single database, creating tight coupling and preventing independent evolution.",
      "concept_ids": [
        "CONCEPT-061"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q042",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the Backend for Frontend (BFF) pattern?",
      "options": [
        "Separate API gateways optimized for each client type (web, mobile, etc.)",
        "Frontend code that runs on backend servers",
        "Backend services for frontend developers",
        "A frontend testing framework"
      ],
      "correct_answer": "Separate API gateways optimized for each client type (web, mobile, etc.)",
      "explanation": "Backend for Frontend (BFF) creates separate API gateways for each client type (web, mobile, third-party), each providing an optimized API.",
      "concept_ids": [
        "CONCEPT-007"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q043",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is Distributed Tracing?",
      "options": [
        "Tracking requests across services using unique correlation IDs",
        "Distributing trace files across servers",
        "Tracing network routes",
        "Debugging distributed systems offline"
      ],
      "correct_answer": "Tracking requests across services using unique correlation IDs",
      "explanation": "Distributed Tracing assigns unique IDs to requests, passes them through all services, and records details for end-to-end visibility and debugging.",
      "concept_ids": [
        "CONCEPT-020"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q044",
      "skill": "recall",
      "topic": "cloud_deployment",
      "difficulty": "easy",
      "format": "mcq",
      "question": "What is Auto Scaling?",
      "options": [
        "Automatically adjusting compute capacity based on demand",
        "Scaling images automatically",
        "Automatic schema scaling",
        "Self-scaling containers"
      ],
      "correct_answer": "Automatically adjusting compute capacity based on demand",
      "explanation": "Auto Scaling automatically adjusts compute capacity based on demand metrics to maintain performance while optimizing costs.",
      "concept_ids": [
        "CONCEPT-040"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q045",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "mcq",
      "question": "What is the Valet Key pattern?",
      "options": [
        "Issuing time-limited tokens for direct resource access without going through the application",
        "A pattern for key management",
        "Storing keys in valet services",
        "Using service accounts"
      ],
      "correct_answer": "Issuing time-limited tokens for direct resource access without going through the application",
      "explanation": "The Valet Key pattern issues time-limited tokens providing direct access to specific resources, allowing clients to bypass the application for storage operations.",
      "concept_ids": [
        "CONCEPT-050"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q046",
      "skill": "recall",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is a Blameless Post-Mortem?",
      "options": [
        "Incident review focused on systemic improvements rather than individual blame",
        "Post-mortem with no conclusions",
        "Review without documentation",
        "Anonymous incident reviews"
      ],
      "correct_answer": "Incident review focused on systemic improvements rather than individual blame",
      "explanation": "Blameless Post-Mortems focus on systemic improvements rather than individual blame, encouraging honest reporting and organizational learning.",
      "concept_ids": [
        "CONCEPT-070"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q048",
      "skill": "recall",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "What is the Competing Consumers pattern?",
      "options": [
        "Multiple consumers pulling from the same queue with each message going to one consumer",
        "Consumers competing for resources",
        "Consumer load balancing",
        "Priority-based consumption"
      ],
      "correct_answer": "Multiple consumers pulling from the same queue with each message going to one consumer",
      "explanation": "Competing Consumers has multiple consumer instances pulling from the same queue, with the messaging system ensuring each message goes to only one consumer.",
      "concept_ids": [
        "CONCEPT-051"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q049",
      "skill": "recall",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "mcq",
      "question": "What is Martin Fowler's 'MonolithFirst' recommendation?",
      "options": [
        "Start with a monolith to discover service boundaries before adopting microservices",
        "Always use monoliths",
        "Build microservices first, then merge into monolith",
        "Monoliths are faster than microservices"
      ],
      "correct_answer": "Start with a monolith to discover service boundaries before adopting microservices",
      "explanation": "MonolithFirst recommends starting with a monolith even for complex applications to discover proper service boundaries before committing to distributed architecture.",
      "concept_ids": [
        "CONCEPT-027"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q051",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team is experiencing cascading failures when one downstream service becomes slow. Requests pile up, exhausting thread pools. Which pattern combination would best address this?",
      "options": [
        "Circuit Breaker with Timeout and Bulkhead",
        "Retry with increased timeout",
        "API Gateway with caching",
        "Database per Service with sharding"
      ],
      "correct_answer": "Circuit Breaker with Timeout and Bulkhead",
      "explanation": "Circuit Breaker stops calling failing services, Timeout prevents indefinite waiting, and Bulkhead isolates resources so one failing dependency doesn't exhaust all threads.",
      "concept_ids": [
        "CONCEPT-001",
        "CONCEPT-009"
      ],
      "sources": [
        "Azure Patterns",
        "microservices.io"
      ]
    },
    {
      "id": "Q052",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A startup is building a new product with uncertain requirements. The CTO is debating between microservices and a monolith. What is the strongest argument for starting with a monolith?",
      "options": [
        "Service boundaries are hard to define correctly upfront, and refactoring across services is much harder than within a monolith",
        "Monoliths are always faster",
        "Microservices require more servers",
        "Monoliths don't need testing"
      ],
      "correct_answer": "Service boundaries are hard to define correctly upfront, and refactoring across services is much harder than within a monolith",
      "explanation": "Per MonolithFirst, defining correct service boundaries is extremely difficult initially, and refactoring functionality between services is much harder than within a monolith.",
      "concept_ids": [
        "CONCEPT-027",
        "CONCEPT-060"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q053",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "When should you choose Saga with Choreography over Orchestration?",
      "options": [
        "When you want loose coupling and services to evolve independently",
        "When you need a clear visualization of the business process",
        "When compensating transactions are complex",
        "When you have a small number of steps"
      ],
      "correct_answer": "When you want loose coupling and services to evolve independently",
      "explanation": "Choreography provides looser coupling as services react to events independently. Orchestration is better when you need clear process visualization or have complex compensation logic.",
      "concept_ids": [
        "CONCEPT-002",
        "CONCEPT-079"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q059",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "An application has a 10:1 read-to-write ratio with complex queries spanning multiple aggregates. Writes require strong consistency. What pattern best addresses this?",
      "options": [
        "CQRS with separate read and write models",
        "Single normalized database",
        "Event Sourcing only",
        "Database sharding"
      ],
      "correct_answer": "CQRS with separate read and write models",
      "explanation": "CQRS allows a strongly consistent write model while maintaining optimized, denormalized read models for complex queries. The high read ratio justifies the complexity.",
      "concept_ids": [
        "CONCEPT-003"
      ],
      "sources": [
        "Martin Fowler",
        "microservices.io"
      ]
    },
    {
      "id": "Q060",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A legacy monolith has 500K lines of code and 200 database tables. The team wants to extract microservices. What's the most significant risk of using Strangler Fig pattern?",
      "options": [
        "Managing data consistency between the legacy system and new services during the transition",
        "The pattern is too complex to implement",
        "It requires rewriting all code at once",
        "Legacy systems cannot coexist with microservices"
      ],
      "correct_answer": "Managing data consistency between the legacy system and new services during the transition",
      "explanation": "During Strangler Fig migration, both systems may need to access or modify the same data, creating consistency challenges that require careful synchronization strategies.",
      "concept_ids": [
        "CONCEPT-008"
      ],
      "sources": [
        "Martin Fowler",
        "Azure Patterns"
      ]
    },
    {
      "id": "Q061",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "When would Event Sourcing be a poor choice despite its benefits?",
      "options": [
        "For simple CRUD applications with no audit requirements and a team unfamiliar with event-driven patterns",
        "When you need a complete audit trail",
        "When debugging production issues is important",
        "When you want temporal queries"
      ],
      "correct_answer": "For simple CRUD applications with no audit requirements and a team unfamiliar with event-driven patterns",
      "explanation": "Event Sourcing adds significant complexity. For simple CRUD without audit needs, and when teams lack experience, traditional state-based persistence is more appropriate.",
      "concept_ids": [
        "CONCEPT-004"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q062",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team implements aggressive retry logic (10 retries, no backoff) when their downstream payment service is slow. Traffic to the payment service increases 10x. What happened?",
      "options": [
        "The retry storm amplified load on the already struggling service, potentially causing complete failure",
        "The payment service got faster from the practice",
        "Retries always help reliability",
        "The retries reduced overall latency"
      ],
      "correct_answer": "The retry storm amplified load on the already struggling service, potentially causing complete failure",
      "explanation": "Aggressive retries without backoff create a 'retry storm' that amplifies load on struggling services, potentially causing complete failure instead of recovery.",
      "concept_ids": [
        "CONCEPT-010",
        "CONCEPT-001"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q065",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A mobile app makes 5 API calls to different microservices on each screen load. Users on cellular networks report slow performance. What pattern would most directly address this?",
      "options": [
        "Gateway Aggregation to combine multiple calls into a single request",
        "Circuit Breaker on each call",
        "Caching on the client",
        "Database optimization"
      ],
      "correct_answer": "Gateway Aggregation to combine multiple calls into a single request",
      "explanation": "Gateway Aggregation combines multiple backend calls into one client request, reducing latency on high-latency networks where round-trip time dominates.",
      "concept_ids": [
        "CONCEPT-049",
        "CONCEPT-006"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q066",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "mcq",
      "question": "Two teams are building services that both need customer data. Team A wants to call Team B's Customer Service API. Team B suggests sharing the database for performance. What's wrong with sharing the database?",
      "options": [
        "It creates tight coupling, preventing independent schema changes and deployments",
        "Databases can't be shared technically",
        "It would be too fast",
        "API calls are always better"
      ],
      "correct_answer": "It creates tight coupling, preventing independent schema changes and deployments",
      "explanation": "Shared databases create tight coupling between services, preventing independent evolution, schema changes, and deployments - violating the Database per Service principle.",
      "concept_ids": [
        "CONCEPT-005",
        "CONCEPT-061"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q069",
      "skill": "analyze",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team wants to add mTLS, observability, and traffic management to 20 microservices without modifying application code. What should they implement?",
      "options": [
        "Service Mesh with sidecar proxies",
        "API Gateway",
        "Application-level libraries in each service",
        "Network policies"
      ],
      "correct_answer": "Service Mesh with sidecar proxies",
      "explanation": "A Service Mesh handles these concerns via sidecar proxies without application code changes, providing uniform security and observability across all services.",
      "concept_ids": [
        "CONCEPT-046"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q071",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A Saga has 5 steps. Step 4 fails after steps 1-3 completed successfully. Step 2 sent an email notification. What challenge does this highlight?",
      "options": [
        "Some actions (like sending emails) cannot be truly compensated, only mitigated",
        "Sagas shouldn't have 5 steps",
        "Email should never be in a Saga",
        "Step 4 should never fail"
      ],
      "correct_answer": "Some actions (like sending emails) cannot be truly compensated, only mitigated",
      "explanation": "Not all actions are reversible. Sent emails can't be unsent - you can only send a correction email. This is a key challenge when designing Saga compensating transactions.",
      "concept_ids": [
        "CONCEPT-002",
        "CONCEPT-080"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q072",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A company with web, iOS, and Android apps is considering BFF vs single API Gateway. Their mobile apps need different data shapes and smaller payloads than web. What's the best approach?",
      "options": [
        "BFF pattern with separate gateways for web and mobile",
        "Single API Gateway serving all clients",
        "Direct service calls from clients",
        "GraphQL for all clients"
      ],
      "correct_answer": "BFF pattern with separate gateways for web and mobile",
      "explanation": "When different clients have significantly different requirements (data shapes, payload sizes), BFF allows optimizing each gateway for its specific client type.",
      "concept_ids": [
        "CONCEPT-007"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q076",
      "skill": "analyze",
      "topic": "technical_debt",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team is planning a complete rewrite of their system 'because the code is too messy.' What consideration from Sacrificial Architecture suggests this might be appropriate?",
      "options": [
        "The system was designed for 10x current scale, and they're approaching 100x",
        "The code has some bugs",
        "The team doesn't like the programming language",
        "A new framework is available"
      ],
      "correct_answer": "The system was designed for 10x current scale, and they're approaching 100x",
      "explanation": "Sacrificial Architecture acknowledges systems designed for one scale may not suit another. Google's principle: design for 10X growth, plan to rewrite before 100X.",
      "concept_ids": [
        "CONCEPT-028"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q078",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "An organization integrated with a legacy ERP system whose data model pollutes their domain model. New code increasingly mirrors legacy concepts. What pattern should they have applied?",
      "options": [
        "Anti-Corruption Layer to translate between legacy and new domain models",
        "Shared database",
        "Direct integration",
        "Complete replacement"
      ],
      "correct_answer": "Anti-Corruption Layer to translate between legacy and new domain models",
      "explanation": "An Anti-Corruption Layer translates between systems with different semantics, preventing legacy models from corrupting the design of new applications.",
      "concept_ids": [
        "CONCEPT-015"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q080",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A company's microservices team structure mirrors their organizational structure per Conway's Law. They want to change the architecture but can't restructure teams. What's a likely outcome?",
      "options": [
        "The new architecture will drift back toward the team structure over time",
        "Architecture will change teams automatically",
        "Conway's Law doesn't apply to microservices",
        "Teams don't affect architecture"
      ],
      "correct_answer": "The new architecture will drift back toward the team structure over time",
      "explanation": "Conway's Law suggests systems reflect organizational communication structures. Without changing team structure, the architecture will naturally drift to match teams.",
      "concept_ids": [
        "CONCEPT-043"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q081",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A public API has 3 active versions (v1, v2, v3). v1 has 1000 users, v2 has 100, v3 is latest. Which version should be prioritized for deprecation?",
      "options": [
        "v2, as it has fewer users and is between stable versions",
        "v1, as it's oldest",
        "v3, as it's newest",
        "Deprecate all at once"
      ],
      "correct_answer": "v2, as it has fewer users and is between stable versions",
      "explanation": "v2 with fewest users minimizes migration impact. Users likely should migrate to v3. v1's larger user base makes it harder to deprecate first.",
      "concept_ids": [
        "CONCEPT-057",
        "CONCEPT-068"
      ],
      "sources": [
        "ADRs",
        "Kubernetes KEPs"
      ]
    },
    {
      "id": "Q082",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A distributed system has logs in each service but debugging cross-service issues takes hours. What's the most impactful improvement?",
      "options": [
        "Implement distributed tracing with correlation IDs across all services",
        "Add more logging",
        "Centralize logs without correlation",
        "Debug each service separately"
      ],
      "correct_answer": "Implement distributed tracing with correlation IDs across all services",
      "explanation": "Distributed tracing with correlation IDs enables following a single request across all services, dramatically reducing time to debug cross-service issues.",
      "concept_ids": [
        "CONCEPT-020",
        "CONCEPT-021"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q084",
      "skill": "analyze",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team deploys 10 times per day using GitOps. They accidentally deploy a broken config. The rollback process takes 30 minutes. What should they improve?",
      "options": [
        "Automate rollback to previous Git commit, which should be instant with GitOps",
        "Deploy less frequently",
        "Add more approvals",
        "Stop using GitOps"
      ],
      "correct_answer": "Automate rollback to previous Git commit, which should be instant with GitOps",
      "explanation": "With GitOps, rollback should be as simple as reverting to a previous Git commit. If it takes 30 minutes, they're not leveraging GitOps' declarative rollback capability.",
      "concept_ids": [
        "CONCEPT-036"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q085",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team's JWT tokens are valid for 24 hours. When a user's access is revoked, they can still access the system until token expiration. What's the trade-off they accepted?",
      "options": [
        "Stateless authentication simplicity versus immediate revocation capability",
        "Longer tokens are more secure",
        "JWT doesn't support revocation",
        "24 hours is the minimum"
      ],
      "correct_answer": "Stateless authentication simplicity versus immediate revocation capability",
      "explanation": "JWT's stateless nature means no central session to invalidate. Short-lived tokens or token blacklists (adding state) are needed for quick revocation.",
      "concept_ids": [
        "CONCEPT-059"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q086",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A company uses Consumer-Driven Contract Testing. A provider team wants to add a required field to an API response. Existing consumer tests would break. What should happen?",
      "options": [
        "Coordinate with consumers first, update contracts, then make the change",
        "Make the change and let consumers adapt",
        "Delete the contract tests",
        "Add the field as optional instead"
      ],
      "correct_answer": "Coordinate with consumers first, update contracts, then make the change",
      "explanation": "Contract tests exist to catch breaking changes. The failing test is working correctly - it detected a breaking change. Consumers must be coordinated before changes.",
      "concept_ids": [
        "CONCEPT-083"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q087",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "An API Gateway handles authentication, rate limiting, and routing. Response times have increased by 50ms. Where is the latency coming from?",
      "options": [
        "The additional network hop and processing at the gateway layer",
        "Database queries",
        "Service processing",
        "Network cables"
      ],
      "correct_answer": "The additional network hop and processing at the gateway layer",
      "explanation": "API Gateways add latency through the extra network hop and processing for features like auth and rate limiting. This is a known trade-off for centralized concerns.",
      "concept_ids": [
        "CONCEPT-006"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q088",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A team implements throttling that returns HTTP 429 when rate limits are exceeded. Their mobile app crashes when receiving 429s. What did the mobile team do wrong?",
      "options": [
        "Failed to implement proper error handling for rate limit responses",
        "Server-side throttling is wrong",
        "HTTP 429 is not a valid status code",
        "Mobile apps shouldn't be throttled"
      ],
      "correct_answer": "Failed to implement proper error handling for rate limit responses",
      "explanation": "Clients must handle throttling responses (429) gracefully, typically implementing backoff and retry. Crashing indicates missing error handling for this expected scenario.",
      "concept_ids": [
        "CONCEPT-011"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q090",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A Saga uses orchestration. The orchestrator becomes a bottleneck and single point of failure. How can this be mitigated while keeping orchestration benefits?",
      "options": [
        "Run multiple orchestrator instances with leader election or partitioned sagas",
        "Switch to choreography",
        "Use bigger servers",
        "Remove the Saga pattern"
      ],
      "correct_answer": "Run multiple orchestrator instances with leader election or partitioned sagas",
      "explanation": "Multiple orchestrator instances with leader election or saga partitioning by key provide scalability and redundancy while maintaining orchestration's clear process visibility.",
      "concept_ids": [
        "CONCEPT-002",
        "CONCEPT-047"
      ],
      "sources": [
        "microservices.io",
        "Azure Patterns"
      ]
    },
    {
      "id": "Q091",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team's post-mortem after an outage focuses on who made the mistake that caused it. Engineers are hesitant to admit errors. What's wrong with this approach?",
      "options": [
        "Blame culture discourages honest reporting and prevents learning about systemic issues",
        "Someone should be blamed",
        "Post-mortems should be shorter",
        "Only major outages need post-mortems"
      ],
      "correct_answer": "Blame culture discourages honest reporting and prevents learning about systemic issues",
      "explanation": "Blameless post-mortems focus on systemic improvements. Blame culture makes people hide mistakes, preventing the organization from learning and improving.",
      "concept_ids": [
        "CONCEPT-070"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q092",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A monolith uses a library for tax calculation. When migrating to microservices, should tax calculation be a separate service?",
      "options": [
        "Not necessarily - if it's a pure calculation with no state, a shared library may be more appropriate",
        "Yes, everything should be a service",
        "No, always use libraries",
        "Depends on the programming language"
      ],
      "correct_answer": "Not necessarily - if it's a pure calculation with no state, a shared library may be more appropriate",
      "explanation": "Pure functions with no state don't require the overhead of a service. The Microservice Premium should be justified - not everything needs to be a service.",
      "concept_ids": [
        "CONCEPT-060"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q093",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A sharded database uses customer ID for sharding. A new requirement needs queries across all customers. What challenge does this create?",
      "options": [
        "Cross-shard queries require scatter-gather across all shards, significantly impacting performance",
        "Sharding prevents all cross-customer queries",
        "Customer ID was wrong for sharding",
        "Add more shards"
      ],
      "correct_answer": "Cross-shard queries require scatter-gather across all shards, significantly impacting performance",
      "explanation": "Sharding optimizes queries within a shard. Cross-shard queries require scatter-gather across all shards, which is expensive. This is a key sharding trade-off.",
      "concept_ids": [
        "CONCEPT-048"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q094",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "An application serves global users. US users report fast response times while EU users report slowness. What's the most likely architectural issue?",
      "options": [
        "Application deployed only in US region, causing high latency for EU users",
        "EU has slower internet",
        "EU users have older devices",
        "Time zone issues"
      ],
      "correct_answer": "Application deployed only in US region, causing high latency for EU users",
      "explanation": "Single-region deployment creates high latency for distant users. Multi-region deployment or CDN for static content would reduce EU latency.",
      "concept_ids": [
        "CONCEPT-032"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q095",
      "skill": "analyze",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A CI pipeline runs all tests on every commit, taking 45 minutes. Developers push directly to main because feature branch testing is too slow. What's the impact?",
      "options": [
        "Broken commits reach main more often because fast feedback loop is lost",
        "Testing becomes more thorough",
        "Deployment is faster",
        "This is the correct approach"
      ],
      "correct_answer": "Broken commits reach main more often because fast feedback loop is lost",
      "explanation": "Slow CI breaks the fast feedback loop that makes CI effective. Developers bypassing it means broken code reaches main, defeating CI's purpose.",
      "concept_ids": [
        "CONCEPT-052"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q097",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A service handles both real-time API requests and batch reporting. During batch jobs, API latency spikes. What pattern would help?",
      "options": [
        "Bulkhead pattern to isolate resources for API vs batch processing",
        "Disable batch processing",
        "Add more servers",
        "Optimize the batch job"
      ],
      "correct_answer": "Bulkhead pattern to isolate resources for API vs batch processing",
      "explanation": "Bulkhead isolates resources (thread pools, connections) so batch processing can't starve API requests. Each has its own resource partition.",
      "concept_ids": [
        "CONCEPT-009"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q098",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "free_response",
      "question": "A team is decomposing a monolith into microservices. They're debating between decomposing by business capability vs. by subdomain. What factors should guide this decision?",
      "correct_answer": "Choose decomposition by business capability when: aligning services with what the business does to generate value, team structure mirrors business functions, clear business ownership exists. Choose subdomain decomposition when: applying DDD principles, domain is complex with core/supporting/generic classification, need to identify strategic differentiators. Both approaches often align; key is deep understanding of both business and domain.",
      "explanation": "Both approaches can work; they often overlap. Business capability aligns with organization, subdomain with domain complexity. Success requires business understanding either way.",
      "concept_ids": [
        "CONCEPT-016",
        "CONCEPT-017"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q099",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A gRPC-based microservices system needs to expose APIs to browser-based web clients. gRPC-Web has limitations. What's the typical solution?",
      "options": [
        "API Gateway that translates REST/HTTP to gRPC for internal services",
        "Rewrite all services in REST",
        "Force browsers to use gRPC",
        "Use WebSockets for everything"
      ],
      "correct_answer": "API Gateway that translates REST/HTTP to gRPC for internal services",
      "explanation": "An API Gateway can expose REST/HTTP to external clients while using efficient gRPC for internal service communication, bridging the browser limitation.",
      "concept_ids": [
        "CONCEPT-006",
        "CONCEPT-076"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q100",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team has 500 alert rules. On-call engineers are overwhelmed with notifications, many of which don't require action. What's the most impactful improvement?",
      "options": [
        "Review and reduce alerts to only actionable items, implementing proper alert hierarchy",
        "Add more on-call engineers",
        "Increase alert thresholds everywhere",
        "Disable alerting"
      ],
      "correct_answer": "Review and reduce alerts to only actionable items, implementing proper alert hierarchy",
      "explanation": "Alert fatigue from non-actionable alerts causes real issues to be missed. Reducing to actionable alerts improves signal-to-noise and on-call effectiveness.",
      "concept_ids": [
        "CONCEPT-021"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q101",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "question": "Compare the trade-offs between using a synchronous API composition pattern versus CQRS for queries spanning multiple services.",
      "correct_answer": "API Composition: Simpler implementation, real-time data, but increased latency (multiple calls), reduced availability (depends on all services), and complex aggregation logic. CQRS: Optimized read models with faster queries, but eventual consistency, increased complexity (separate read/write models), and data synchronization overhead. Choose API Composition for simpler queries with strong consistency needs. Choose CQRS for complex queries, high read:write ratios, or when eventual consistency is acceptable.",
      "explanation": "The choice depends on consistency requirements, query complexity, read:write ratio, and team capacity to manage CQRS complexity.",
      "concept_ids": [
        "CONCEPT-003",
        "CONCEPT-063"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q102",
      "skill": "analyze",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team using Kubernetes notices their Service load balancing is uneven - some pods get 80% of traffic. What's likely happening?",
      "options": [
        "Long-lived connections prevent even distribution; need connection draining or service mesh",
        "Kubernetes load balancing is broken",
        "Some pods are faster",
        "Labels are wrong"
      ],
      "correct_answer": "Long-lived connections prevent even distribution; need connection draining or service mesh",
      "explanation": "Kubernetes Service uses connection-level load balancing. Long-lived connections (gRPC, WebSocket) stay on initial pods. Request-level balancing needs service mesh or client-side LB.",
      "concept_ids": [
        "CONCEPT-046"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q104",
      "skill": "analyze",
      "topic": "technical_debt",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team categorizes their technical debt using the Technical Debt Quadrant. Which quadrant represents the worst kind of debt?",
      "options": [
        "Reckless and Inadvertent - 'We didn't know we were taking on debt'",
        "Prudent and Deliberate",
        "Reckless and Deliberate",
        "Prudent and Inadvertent"
      ],
      "correct_answer": "Reckless and Inadvertent - 'We didn't know we were taking on debt'",
      "explanation": "Reckless/Inadvertent debt (not knowing best practices) is worst because the team doesn't even recognize they're accumulating debt, so they can't plan to address it.",
      "concept_ids": [
        "CONCEPT-029"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q105",
      "skill": "analyze",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "free_response",
      "question": "Explain why refactoring functionality between services is harder than within a monolith, as stated in the MonolithFirst recommendation.",
      "correct_answer": "Within a monolith: refactoring is a local code change with IDE support, tests run together, deployment is atomic, and rollback is simple. Between services: refactoring requires changing APIs (breaking consumers), coordinating deployments, maintaining backward compatibility during transition, dealing with distributed data movement, handling network failures, and managing potentially different languages/technologies. The distributed nature transforms a code refactoring into an architectural and operational challenge.",
      "explanation": "Service boundaries create hard contracts. Moving functionality requires API versioning, data migration, coordinated deployments, and handling distributed system challenges.",
      "concept_ids": [
        "CONCEPT-027",
        "CONCEPT-060"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q106",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team implemented Queue-Based Load Leveling for their batch processing system. The queue keeps growing even during low-traffic periods. What's the likely issue?",
      "options": [
        "Consumer processing rate is lower than average message production rate",
        "The queue is too small",
        "Messages are too large",
        "The pattern is wrong for batch processing"
      ],
      "correct_answer": "Consumer processing rate is lower than average message production rate",
      "explanation": "If the queue grows continuously, consumers can't keep up with producers even at average rates. Either add consumers or optimize processing.",
      "concept_ids": [
        "CONCEPT-012"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q108",
      "skill": "analyze",
      "topic": "cloud_deployment",
      "difficulty": "hard",
      "format": "mcq",
      "question": "A team uses blue-green deployment. Their database schema changed in the green environment. After switching traffic, they need to rollback. Why is this problematic?",
      "options": [
        "Database schema changes may not be backward compatible, preventing rollback to blue",
        "Blue-green doesn't support databases",
        "Rollback is always instant",
        "Schema changes are automatic"
      ],
      "correct_answer": "Database schema changes may not be backward compatible, preventing rollback to blue",
      "explanation": "Blue-green works well for stateless services. Database schema migrations can break backward compatibility, making the 'blue' version unable to work with the new schema.",
      "concept_ids": [
        "CONCEPT-054"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q109",
      "skill": "analyze",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "A team stores configuration in environment variables. They need to update a config value across 50 service instances. What's the operational challenge?",
      "options": [
        "Environment variable changes require restarting all instances, causing potential downtime",
        "Environment variables can't be changed",
        "50 instances is too many",
        "Configuration should be in code"
      ],
      "correct_answer": "Environment variable changes require restarting all instances, causing potential downtime",
      "explanation": "Environment variables are read at startup. Changes require restarts or rolling deployments. An external configuration store enables runtime updates without restarts.",
      "concept_ids": [
        "CONCEPT-081"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q110",
      "skill": "analyze",
      "topic": "quality_attributes",
      "difficulty": "hard",
      "format": "free_response",
      "question": "A system needs to handle a flash sale event where traffic might spike 100x for 1 hour. Analyze the trade-offs between pre-provisioning capacity versus auto-scaling.",
      "correct_answer": "Pre-provisioning: Guaranteed capacity for spike, no scaling lag, but expensive for idle time (99%+ of hours), wastes resources. Auto-scaling: Cost-effective for normal operations, but scaling lag may miss initial spike, cold starts affect performance, may not scale fast enough for 100x spike, need to test actual scaling behavior. Hybrid approach often best: pre-scale some capacity before known event, enable aggressive auto-scaling for additional demand, scale down afterward. For known events, pre-provisioning often wins on reliability.",
      "explanation": "Known, extreme spikes often justify pre-provisioning cost. Unknown spikes need auto-scaling. The 100x magnitude and known timing favor pre-provisioning here.",
      "concept_ids": [
        "CONCEPT-040",
        "CONCEPT-039"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q113",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a disaster recovery strategy for a critical financial application. Requirements: RTO of 4 hours, RPO of 15 minutes, budget constraints prevent active-active in multiple regions. Which approach best fits?",
      "options": [
        "Warm standby in secondary region with continuous replication and automated failover",
        "Daily backups to another region",
        "Active-active multi-region deployment",
        "Cold standby with weekly backups"
      ],
      "correct_answer": "Warm standby in secondary region with continuous replication and automated failover",
      "explanation": "Warm standby meets the 4-hour RTO (quick spinup) and 15-minute RPO (continuous replication) without the cost of active-active. Cold standby is too slow for 4-hour RTO.",
      "concept_ids": [
        "CONCEPT-033",
        "CONCEPT-034"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q116",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "free_response",
      "question": "Design API versioning strategy for a public API with 500 enterprise customers. Requirements: 6-month deprecation window, clear migration path, support parallel versions, minimize customer disruption. Include versioning approach and deprecation process.",
      "correct_answer": "Versioning approach: URL path versioning (/v1/, /v2/) for clarity and routing simplicity. Process: 1) New version development in parallel with current version. 2) Announce deprecation with 6-month countdown in API responses (Sunset header, deprecation warnings). 3) Provide migration guides and SDK updates. 4) Analytics to track version usage per customer. 5) Direct outreach to customers still on deprecated versions. 6) Grace period extensions for strategic customers. 7) Final deprecation with clear cutoff date. Technical: API Gateway routes by version, shared backend services where compatible, version-specific adapters where needed. Documentation: Changelog, migration guide, version comparison, sunset timeline. Communication: Email announcements, developer portal notices, API response warnings.",
      "explanation": "URL versioning is most explicit for enterprise customers. The deprecation process balances business needs with technical evolution.",
      "concept_ids": [
        "CONCEPT-057",
        "CONCEPT-068"
      ],
      "sources": [
        "ADRs",
        "Kubernetes KEPs"
      ]
    },
    {
      "id": "Q117",
      "skill": "design",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a caching strategy for a product catalog service. Requirements: 1M products, 100K reads/minute, updates every 5 minutes from suppliers, 99.9% cache hit rate target. Products have images (10MB each) and metadata (1KB). Which approach?",
      "options": [
        "Redis for metadata cache-aside, CDN for images, async cache invalidation on updates",
        "Cache everything in Redis including images",
        "No caching, scale the database",
        "Browser caching only"
      ],
      "correct_answer": "Redis for metadata cache-aside, CDN for images, async cache invalidation on updates",
      "explanation": "Separate concerns: Redis efficiently caches small metadata, CDN handles large images at edge. Cache-aside with async invalidation handles the 5-minute update cycle appropriately.",
      "concept_ids": [
        "CONCEPT-038"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q121",
      "skill": "design",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a CI/CD pipeline for a microservices team. Requirements: 10 services in a monorepo, independent deployments, automated testing, deployment to Kubernetes. Which approach?",
      "options": [
        "Selective builds based on changed paths, service-specific pipelines, GitOps with ArgoCD for deployment",
        "Single pipeline that builds and deploys everything on every change",
        "Manual deployments after testing",
        "Branch per service with merge to main for deployment"
      ],
      "correct_answer": "Selective builds based on changed paths, service-specific pipelines, GitOps with ArgoCD for deployment",
      "explanation": "Path-based selective builds handle monorepo efficiency. Service-specific pipelines enable independent deployments. ArgoCD provides GitOps-based Kubernetes deployment.",
      "concept_ids": [
        "CONCEPT-052",
        "CONCEPT-053",
        "CONCEPT-036"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q124",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "hard",
      "format": "free_response",
      "question": "Design a data mesh architecture for a large enterprise with multiple business domains: Sales, Marketing, Finance, Operations. Each domain should own their data products. Include governance and interoperability considerations.",
      "correct_answer": "Data Mesh Design: Domain-oriented ownership: Each domain (Sales, Marketing, Finance, Ops) owns data products as first-class citizens. Infrastructure: 1) Self-serve data platform providing compute, storage, and catalog capabilities, 2) Federated computational governance with automated policy enforcement, 3) Standardized interfaces (APIs, event streams) for data product consumption. Data Products per domain: Sales (leads, opportunities, forecasts), Marketing (campaigns, attribution, segments), Finance (revenue, costs, budgets), Ops (inventory, fulfillment, logistics). Interoperability: 1) Standard metadata schemas across domains, 2) Data contracts with SLOs, 3) Cross-domain access via governed APIs, 4) Central catalog for discovery. Governance: Automated quality checks, data lineage tracking, access policies, retention compliance. Implementation: Start with one domain, prove model, expand. Anti-pattern to avoid: central data team owning all data.",
      "explanation": "Data mesh applies domain-driven design to data, with domains owning their data products. Self-serve platform and federated governance enable scaling.",
      "concept_ids": [
        "CONCEPT-017",
        "CONCEPT-018",
        "CONCEPT-065"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q125",
      "skill": "design",
      "topic": "cloud_deployment",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design auto-scaling for an e-commerce platform expecting 10x traffic during flash sales (known events) and 3x spikes during normal operation (unknown events). Which scaling configuration?",
      "options": [
        "Scheduled scaling for known events, target tracking for normal operation, with pre-warming for flash sales",
        "Manual scaling before flash sales",
        "Only reactive auto-scaling based on CPU",
        "Fixed capacity for peak load"
      ],
      "correct_answer": "Scheduled scaling for known events, target tracking for normal operation, with pre-warming for flash sales",
      "explanation": "Scheduled scaling pre-provisions for known 10x events. Target tracking handles unknown 3x spikes reactively. Pre-warming ensures instances are ready for traffic.",
      "concept_ids": [
        "CONCEPT-040"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q131",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a data backup strategy for a globally distributed application with databases in 3 regions. Requirements: cross-region recovery, 1-hour RPO, 4-hour RTO, encryption at rest.",
      "options": [
        "Continuous replication to central backup region, point-in-time recovery enabled, encrypted snapshots, tested restore procedures",
        "Daily backups to same region",
        "Manual exports weekly",
        "No backups, rely on replication"
      ],
      "correct_answer": "Continuous replication to central backup region, point-in-time recovery enabled, encrypted snapshots, tested restore procedures",
      "explanation": "Continuous replication meets 1-hour RPO. Central backup enables cross-region recovery. Point-in-time recovery provides flexibility. Tested procedures ensure 4-hour RTO.",
      "concept_ids": [
        "CONCEPT-033",
        "CONCEPT-034"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q133",
      "skill": "design",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design message handling for an order system where processing must happen exactly once. Messages may be redelivered due to consumer failures. Which approach ensures correctness?",
      "options": [
        "Idempotent consumer with message ID tracking in the same transaction as business logic",
        "Rely on exactly-once delivery from message broker",
        "Process all messages regardless of duplicates",
        "Manual deduplication by operators"
      ],
      "correct_answer": "Idempotent consumer with message ID tracking in the same transaction as business logic",
      "explanation": "Most message systems provide at-least-once delivery. Idempotent consumers with transactional ID tracking ensure exactly-once processing semantics.",
      "concept_ids": [
        "CONCEPT-024"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q135",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design an SLO framework for a microservices platform. You need to define SLOs, measure SLIs, and create error budgets. Which approach is most comprehensive?",
      "options": [
        "Define latency (p99) and availability SLOs per service, measure with distributed tracing, calculate error budget burn rate for release decisions",
        "Track only uptime percentage",
        "Use average latency for all measurements",
        "Measure only customer complaints"
      ],
      "correct_answer": "Define latency (p99) and availability SLOs per service, measure with distributed tracing, calculate error budget burn rate for release decisions",
      "explanation": "P99 latency captures tail experience. Per-service SLOs enable accountability. Error budgets tie reliability to deployment velocity.",
      "concept_ids": [
        "CONCEPT-021",
        "CONCEPT-020"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q137",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design data contracts between services in a microservices architecture. The Order Service needs Customer data from Customer Service. Which approach minimizes coupling while ensuring reliability?",
      "options": [
        "Customer Service publishes events with required data, Order Service maintains local cache updated via events",
        "Order Service directly queries Customer database",
        "Shared Customer library across all services",
        "Synchronous API call on every order"
      ],
      "correct_answer": "Customer Service publishes events with required data, Order Service maintains local cache updated via events",
      "explanation": "Event-driven data sharing minimizes runtime coupling. Local cache provides availability. Events define the contract. This is the Data Mesh/event-carried state transfer pattern.",
      "concept_ids": [
        "CONCEPT-005",
        "CONCEPT-062"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q139",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a chaos engineering program for a company new to the practice. They have 20 microservices in production with basic monitoring. What's the best starting approach?",
      "options": [
        "Start with GameDays in staging, simple failure injection (pod kill), graduate to production with small blast radius",
        "Immediately run chaos experiments in production at scale",
        "Only theoretical analysis without actual injection",
        "Chaos engineering only after all services are fully resilient"
      ],
      "correct_answer": "Start with GameDays in staging, simple failure injection (pod kill), graduate to production with small blast radius",
      "explanation": "Start small and safe: staging first, simple failures, build confidence and improve observability before production. Gradually increase scope and complexity.",
      "concept_ids": [
        "CONCEPT-037"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q141",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design service communication for an order processing system. Order Service needs to call Payment Service (critical, needs response) and Notification Service (non-critical, can fail). Which communication patterns?",
      "options": [
        "Synchronous call with Circuit Breaker for Payment, async message queue for Notification",
        "Synchronous calls for both with long timeouts",
        "Async message queue for both",
        "Direct database sharing"
      ],
      "correct_answer": "Synchronous call with Circuit Breaker for Payment, async message queue for Notification",
      "explanation": "Critical paths (Payment) need synchronous calls with resilience patterns. Non-critical paths (Notification) benefit from async decoupling - failure doesn't block order.",
      "concept_ids": [
        "CONCEPT-001",
        "CONCEPT-023"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q143",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a structured error handling strategy for a public API. Errors need to be: actionable for clients, secure (no internal details exposed), consistent across services, and debuggable for operators.",
      "options": [
        "RFC 7807 Problem Details format with error codes, correlation IDs in response and logs, separate internal vs external error messages",
        "Stack traces in API responses",
        "Generic 500 Internal Server Error for all failures",
        "Error codes without descriptions"
      ],
      "correct_answer": "RFC 7807 Problem Details format with error codes, correlation IDs in response and logs, separate internal vs external error messages",
      "explanation": "RFC 7807 provides standard format. Error codes enable client handling. Correlation IDs link client errors to server logs. Separation protects internals.",
      "concept_ids": [
        "CONCEPT-066"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q145",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a testing strategy for microservices. You have 15 services with complex dependencies. Full integration tests take 2 hours. How do you balance test coverage with developer productivity?",
      "options": [
        "Unit tests per service, contract tests for service boundaries, selective integration tests based on changes, full integration in nightly builds",
        "Only unit tests for speed",
        "Only full integration tests for coverage",
        "Manual testing only"
      ],
      "correct_answer": "Unit tests per service, contract tests for service boundaries, selective integration tests based on changes, full integration in nightly builds",
      "explanation": "Testing pyramid: fast unit tests for most coverage, contract tests catch interface breaks, selective integration for changed areas, comprehensive nightly for full validation.",
      "concept_ids": [
        "CONCEPT-083",
        "CONCEPT-052"
      ],
      "sources": [
        "microservices.io"
      ]
    },
    {
      "id": "Q149",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design team structure for a microservices platform with 8 services. Each service should be owned by a team, but you only have 25 engineers. How should teams be organized?",
      "options": [
        "3-4 cross-functional teams, each owning 2-3 related services based on domain boundaries",
        "One team owning all services",
        "8 teams with 3 engineers each",
        "Separate teams for frontend, backend, and DevOps"
      ],
      "correct_answer": "3-4 cross-functional teams, each owning 2-3 related services based on domain boundaries",
      "explanation": "Two-pizza team size (6-8 people) owns related services within a domain. Cross-functional includes all needed skills. Aligns with Conway's Law.",
      "concept_ids": [
        "CONCEPT-043",
        "CONCEPT-016"
      ],
      "sources": [
        "Martin Fowler"
      ]
    },
    {
      "id": "Q151",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design an incident response process for a 24/7 SaaS platform. Team of 20 engineers across 3 time zones. Need: clear escalation, minimal burnout, effective communication.",
      "options": [
        "Follow-the-sun on-call rotation, severity-based escalation matrix, incident commander role, post-incident reviews, runbooks for common issues",
        "Single person on-call 24/7",
        "No on-call, address issues next business day",
        "Entire team responds to every incident"
      ],
      "correct_answer": "Follow-the-sun on-call rotation, severity-based escalation matrix, incident commander role, post-incident reviews, runbooks for common issues",
      "explanation": "Follow-the-sun leverages time zones to avoid 24-hour on-call. Severity-based escalation prevents over-alerting. Incident commander coordinates response. Runbooks enable efficient resolution.",
      "concept_ids": [
        "CONCEPT-070",
        "CONCEPT-066"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q153",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design an integration strategy for a microservices platform that must connect with 20 different external partners. Each partner has different API formats, auth methods, and reliability characteristics.",
      "options": [
        "Integration Service with adapter per partner, circuit breakers per partner, async messaging for non-real-time, standardized internal events",
        "Direct calls from each microservice to partners",
        "Single universal API wrapper",
        "Manual integration scripts"
      ],
      "correct_answer": "Integration Service with adapter per partner, circuit breakers per partner, async messaging for non-real-time, standardized internal events",
      "explanation": "Adapter pattern handles API differences. Circuit breakers isolate partner failures. Async messaging decouples when possible. Internal events standardize consumption.",
      "concept_ids": [
        "CONCEPT-015",
        "CONCEPT-001"
      ],
      "sources": [
        "Azure Patterns"
      ]
    },
    {
      "id": "Q157",
      "skill": "design",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "mcq",
      "question": "You're designing a platform that will be white-labeled for multiple enterprise customers. Each customer wants customization: branding, feature toggles, custom fields. What's the best multi-tenancy approach?",
      "options": [
        "Shared infrastructure with tenant-aware customization layer, configuration per tenant, feature flags for optional features",
        "Separate deployment per customer",
        "Fork the codebase per customer",
        "No customization allowed"
      ],
      "correct_answer": "Shared infrastructure with tenant-aware customization layer, configuration per tenant, feature flags for optional features",
      "explanation": "Shared infrastructure reduces operational burden. Tenant-aware customization layer handles branding/fields. Feature flags enable per-tenant features. Single codebase is maintainable.",
      "concept_ids": [
        "CONCEPT-056",
        "CONCEPT-081"
      ],
      "sources": [
        "ADRs"
      ]
    },
    {
      "id": "Q159",
      "skill": "design",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "mcq",
      "question": "Design a sustainable architecture for a cloud application. The company has committed to carbon neutrality. Which design choices most directly reduce environmental impact?",
      "options": [
        "Right-size resources for high utilization, schedule non-critical jobs for low-carbon periods, use serverless for variable workloads, prefer managed services",
        "Use the largest instances available",
        "Run 24/7 at peak capacity",
        "Deploy in multiple regions for redundancy only"
      ],
      "correct_answer": "Right-size resources for high utilization, schedule non-critical jobs for low-carbon periods, use serverless for variable workloads, prefer managed services",
      "explanation": "Higher utilization means less idle capacity. Scheduling for low-carbon grid periods reduces emissions. Serverless and managed services share resources efficiently.",
      "concept_ids": [
        "CONCEPT-071"
      ],
      "sources": [
        "AWS Well-Architected"
      ]
    },
    {
      "id": "Q163",
      "question": "Given this Saga orchestrator pseudocode, identify and fix the bug:\n\n```python\nclass OrderSaga:\n    def execute(self):\n        try:\n            self.reserve_inventory()\n            self.charge_payment()\n            self.ship_order()\n        except PaymentError:\n            self.release_inventory()\n        except ShippingError:\n            self.refund_payment()\n```\n\nWhat compensating transactions are missing?",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-019"
      ],
      "source": "microservices_io",
      "expected_answer": "ShippingError handler should also release inventory. Need proper ordering: release_inventory() then refund_payment() for ShippingError."
    },
    {
      "id": "Q167",
      "question": "Complete the Event Sourcing aggregate implementation:\n\n```python\nclass BankAccount:\n    def __init__(self, account_id):\n        self.account_id = account_id\n        self.balance = 0\n        self.events = []\n    \n    def apply_event(self, event):\n        # TODO: Apply event to update state\n        pass\n    \n    def deposit(self, amount):\n        # TODO: Create and apply event\n        pass\n    \n    def withdraw(self, amount):\n        # TODO: Create and apply event, handle insufficient funds\n        pass\n    \n    def replay_events(self, events):\n        # TODO: Rebuild state from event history\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-021"
      ],
      "source": "microservices_io",
      "expected_answer": "apply_event should pattern match on event type and update balance. deposit/withdraw create event dicts with type/amount, append to events list, call apply_event. replay_events iterates and applies each event."
    },
    {
      "id": "Q169",
      "question": "Implement a basic API Gateway rate limiter using Redis:\n\n```python\nimport redis\nimport time\n\nclass RateLimiter:\n    def __init__(self, redis_client, requests_per_minute=60):\n        self.redis = redis_client\n        self.limit = requests_per_minute\n    \n    def is_allowed(self, client_id: str) -> bool:\n        # TODO: Implement sliding window rate limiting\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-030",
        "CONCEPT-046"
      ],
      "source": "azure_patterns",
      "expected_answer": "Use Redis sorted set with timestamp scores. Add current timestamp, remove entries older than window, count remaining entries, compare against limit."
    },
    {
      "id": "Q172",
      "question": "Complete the CQRS command handler:\n\n```python\nclass CreateOrderCommand:\n    def __init__(self, order_id, customer_id, items):\n        self.order_id = order_id\n        self.customer_id = customer_id\n        self.items = items\n\nclass CreateOrderHandler:\n    def __init__(self, event_store, event_publisher):\n        self.event_store = event_store\n        self.event_publisher = event_publisher\n    \n    def handle(self, command: CreateOrderCommand):\n        # TODO: Validate, create event, store, and publish\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "free_response",
      "concepts": [
        "CONCEPT-020"
      ],
      "source": "microservices_io",
      "expected_answer": "Validate command data, create OrderCreatedEvent with command data, persist to event_store, publish via event_publisher, return success/event_id."
    },
    {
      "id": "Q174",
      "question": "Implement the Strangler Fig pattern for migrating a legacy endpoint. Complete the proxy:\n\n```python\nclass StranglerProxy:\n    def __init__(self, legacy_url, new_service_url):\n        self.legacy_url = legacy_url\n        self.new_service_url = new_service_url\n        self.migrated_endpoints = set()\n    \n    async def route_request(self, method, path, body=None, headers=None):\n        # TODO: Route to new service if migrated, otherwise to legacy\n        pass\n    \n    def mark_migrated(self, path_pattern):\n        # TODO: Mark an endpoint as migrated\n        pass\n```",
      "skill": "implement",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "free_response",
      "concepts": [
        "CONCEPT-041",
        "CONCEPT-082"
      ],
      "source": "fowler",
      "expected_answer": "route_request checks if path matches any migrated_endpoints patterns, forwards to new_service_url if matched, legacy_url otherwise. mark_migrated adds pattern to set."
    },
    {
      "id": "Q177",
      "question": "What's the bug in this distributed lock implementation?\n\n```python\nimport redis\nimport uuid\n\nclass DistributedLock:\n    def __init__(self, redis_client, lock_name, ttl=30):\n        self.redis = redis_client\n        self.lock_name = lock_name\n        self.ttl = ttl\n        self.lock_id = str(uuid.uuid4())\n    \n    def acquire(self):\n        return self.redis.set(self.lock_name, self.lock_id, nx=True, ex=self.ttl)\n    \n    def release(self):\n        self.redis.delete(self.lock_name)\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-074"
      ],
      "source": "azure_patterns",
      "expected_answer": "Release doesn't verify lock ownership - could delete another process's lock. Should use Lua script or WATCH/MULTI to atomically check lock_id matches before deleting."
    },
    {
      "id": "Q178",
      "question": "Complete the Bulkhead pattern implementation using semaphores:\n\n```python\nimport asyncio\nfrom typing import Dict\n\nclass BulkheadManager:\n    def __init__(self):\n        self.bulkheads: Dict[str, asyncio.Semaphore] = {}\n    \n    def register_bulkhead(self, name: str, max_concurrent: int):\n        # TODO: Create semaphore for this bulkhead\n        pass\n    \n    async def execute(self, bulkhead_name: str, func, *args, **kwargs):\n        # TODO: Execute function within bulkhead limits\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "free_response",
      "concepts": [
        "CONCEPT-027"
      ],
      "source": "azure_patterns",
      "expected_answer": "register_bulkhead creates Semaphore(max_concurrent) in dict. execute uses 'async with self.bulkheads[bulkhead_name]' to acquire semaphore, then awaits func(*args, **kwargs)."
    },
    {
      "id": "Q181",
      "question": "Write the Kubernetes NetworkPolicy YAML to:\n- Allow ingress only from pods with label 'app: frontend'\n- Allow egress only to pods with label 'app: database' on port 5432\n- Deny all other traffic",
      "skill": "implement",
      "topic": "quality_attributes",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-004",
        "CONCEPT-055"
      ],
      "source": "kubernetes_keps",
      "expected_answer": "NetworkPolicy with podSelector, policyTypes [Ingress, Egress], ingress rule with from podSelector matching app:frontend, egress rule with to podSelector matching app:database and ports [5432]."
    },
    {
      "id": "Q186",
      "question": "Fix the race condition in this cache-aside implementation:\n\n```python\nclass CacheAside:\n    def __init__(self, cache, database):\n        self.cache = cache\n        self.db = database\n    \n    async def get(self, key):\n        value = await self.cache.get(key)\n        if value is None:\n            value = await self.db.get(key)\n            await self.cache.set(key, value)\n        return value\n    \n    async def update(self, key, value):\n        await self.db.update(key, value)\n        await self.cache.delete(key)\n```\n\nWhat's the race condition and how would you fix it?",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-074"
      ],
      "source": "azure_patterns",
      "expected_answer": "Race: Thread A reads stale from DB, Thread B updates DB and deletes cache, Thread A writes stale value to cache. Fix: Use cache.delete() before db.update(), or use distributed locking, or add TTL to cached values."
    },
    {
      "id": "Q191",
      "question": "Complete the BFF (Backend for Frontend) implementation:\n\n```python\nclass MobileBFF:\n    def __init__(self, user_service, order_service, product_service):\n        self.users = user_service\n        self.orders = order_service\n        self.products = product_service\n    \n    async def get_home_screen_data(self, user_id: str) -> dict:\n        # TODO: Aggregate data optimized for mobile home screen\n        # Should include: user profile summary, recent orders (last 3),\n        # recommended products (limit 5)\n        # Optimize for minimal payload size\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "medium",
      "format": "free_response",
      "concepts": [
        "CONCEPT-047"
      ],
      "source": "microservices_io",
      "expected_answer": "Use asyncio.gather to fetch user, orders, products in parallel. Transform responses to include only needed fields (name not full profile, order summary not details, product thumbnails not full images). Return combined dict."
    },
    {
      "id": "Q192",
      "question": "Implement idempotency key handling for a payment API:\n\n```python\nclass PaymentService:\n    def __init__(self, db, payment_gateway):\n        self.db = db\n        self.gateway = payment_gateway\n    \n    async def process_payment(self, idempotency_key: str, amount: float, \n                              customer_id: str) -> dict:\n        # TODO: Implement idempotent payment processing\n        # - Check if request was already processed\n        # - If yes, return cached result\n        # - If no, process and store result\n        # - Handle in-progress requests\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-074"
      ],
      "source": "real_adrs",
      "expected_answer": "Check db for idempotency_key. If exists with status='completed', return stored result. If status='in_progress', return 409 or wait. If not exists, insert with status='in_progress', call gateway, update with result and status='completed', return result. Use transaction/lock."
    },
    {
      "id": "Q194",
      "question": "Implement a simple message deduplication handler:\n\n```python\nfrom datetime import datetime, timedelta\n\nclass MessageDeduplicator:\n    def __init__(self, redis_client, dedup_window_minutes=60):\n        self.redis = redis_client\n        self.window = dedup_window_minutes\n    \n    async def is_duplicate(self, message_id: str) -> bool:\n        # TODO: Check if message was seen within dedup window\n        pass\n    \n    async def mark_processed(self, message_id: str):\n        # TODO: Record message as processed\n        pass\n    \n    async def process_if_new(self, message_id: str, handler_func):\n        # TODO: Only process if not duplicate\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "easy",
      "format": "free_response",
      "concepts": [
        "CONCEPT-028"
      ],
      "source": "microservices_io",
      "expected_answer": "is_duplicate: return await redis.exists(f'dedup:{message_id}'). mark_processed: await redis.setex(f'dedup:{message_id}', window*60, '1'). process_if_new: if not await is_duplicate, call handler_func, then mark_processed."
    },
    {
      "id": "Q195",
      "question": "Fix the observability gap in this async task processor:\n\n```python\nasync def process_task(task):\n    result = await heavy_computation(task.data)\n    await save_result(task.id, result)\n    return result\n\nasync def worker():\n    while True:\n        task = await queue.get()\n        try:\n            await process_task(task)\n        except Exception:\n            pass\n        finally:\n            queue.task_done()\n```\n\nAdd proper logging, metrics, and tracing.",
      "skill": "implement",
      "topic": "quality_attributes",
      "difficulty": "medium",
      "format": "free_response",
      "concepts": [
        "CONCEPT-065",
        "CONCEPT-066",
        "CONCEPT-068"
      ],
      "source": "microservices_io",
      "expected_answer": "Add: structured logging with task_id/status, try/except with logger.exception(), metrics for tasks_processed/failed/duration histogram, span creation with task context, propagate trace_id if present in task."
    },
    {
      "id": "Q196",
      "question": "Implement a configuration-driven feature toggle system:\n\n```yaml\n# config.yaml\nfeatures:\n  new_checkout:\n    enabled: true\n    rollout_percentage: 25\n    whitelist_users: [\"user123\", \"user456\"]\n    blacklist_users: []\n```\n\n```python\nclass FeatureConfig:\n    def __init__(self, config_path: str):\n        # TODO: Load and parse config\n        pass\n    \n    def is_feature_enabled(self, feature_name: str, user_id: str = None) -> bool:\n        # TODO: Evaluate feature for user\n        pass\n```",
      "skill": "implement",
      "topic": "cloud_deployment",
      "difficulty": "easy",
      "format": "free_response",
      "concepts": [
        "CONCEPT-059"
      ],
      "source": "fowler",
      "expected_answer": "Load YAML in __init__. is_feature_enabled: get feature config, check enabled flag, if user_id in blacklist return False, if in whitelist return True, else hash(user_id) % 100 < rollout_percentage."
    },
    {
      "id": "Q199",
      "question": "Complete this ADR template for choosing between REST and gRPC:\n\n```markdown\n# ADR-XXX: API Protocol for Inter-Service Communication\n\n## Status\n[TODO]\n\n## Context\nWe need to choose an API protocol for communication between our microservices.\nCurrent services: Order, Inventory, Payment, Notification\nRequirements: Low latency (<10ms p99), type safety, streaming for notifications\n\n## Decision\n[TODO - Choose and justify]\n\n## Consequences\n[TODO - List positive and negative consequences]\n```",
      "skill": "implement",
      "topic": "decomposition",
      "difficulty": "medium",
      "format": "free_response",
      "concepts": [
        "CONCEPT-079",
        "CONCEPT-029"
      ],
      "source": "real_adrs",
      "expected_answer": "Status: Proposed/Accepted. Decision: gRPC for internal services due to latency requirements, type safety via protobuf, native streaming support. Consequences: (+) Performance, type safety, streaming; (-) Debugging harder, need protobuf tooling, team learning curve, REST gateway needed for external clients."
    },
    {
      "id": "Q200",
      "question": "Implement a basic leader election mechanism using Redis:\n\n```python\nimport redis\nimport asyncio\nfrom typing import Optional, Callable\n\nclass LeaderElection:\n    def __init__(self, redis_client, election_key: str, \n                 instance_id: str, ttl_seconds: int = 30):\n        self.redis = redis_client\n        self.key = election_key\n        self.instance_id = instance_id\n        self.ttl = ttl_seconds\n        self.is_leader = False\n    \n    async def try_become_leader(self) -> bool:\n        # TODO: Attempt to acquire leadership\n        pass\n    \n    async def renew_leadership(self) -> bool:\n        # TODO: Extend TTL if still leader\n        pass\n    \n    async def resign(self):\n        # TODO: Give up leadership\n        pass\n    \n    async def leader_loop(self, on_leader: Callable, on_follower: Callable):\n        # TODO: Continuously try to become/stay leader\n        pass\n```",
      "skill": "implement",
      "topic": "architectural_patterns",
      "difficulty": "hard",
      "format": "free_response",
      "concepts": [
        "CONCEPT-074"
      ],
      "source": "azure_patterns",
      "expected_answer": "try_become_leader: SET key instance_id NX EX ttl, return success. renew_leadership: check if current value == instance_id, if yes EXPIRE/SET with new ttl, else return false. resign: check ownership then DELETE. leader_loop: while True, if is_leader try renew else try become, call appropriate callback, sleep ttl/3."
    }
  ]
}